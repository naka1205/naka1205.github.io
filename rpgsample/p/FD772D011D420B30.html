<!DOCTYPE HTML>
<html lang=""> 
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>CG/Sprite的重叠显示 · C++实例教程</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="description" content="其实杀鸡焉用牛刀、各位不需要用到Windows功能就能自己处理CG重叠。不但变通性高,而且现在电脑的CPU的速度等级够快了,即使成果差强人意也应该能用才对。">
    <meta name="keywords" content="角色扮演 教程">
    <meta name="generator" content="PKBook">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/style.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/search.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/ebook.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/website.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/github.min.css" rel="stylesheet">
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://naka1205.github.io/rpgsample/assets/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://naka1205.github.io/rpgsample/assets/images/favicon.ico" type="image/x-icon">
</head>
<body>
<div class="book">
    <div class="book-summary">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="输入关键词搜索" />
        </div>
        <nav role="navigation">
    <ul class="summary">
        <li><a href="https://naka1205.github.io/rpgsample/index.html" target="blank" class="header">说明</a></li>
        <li class="divider"></li>
                <li class="header">写一个角色扮演游戏</li>
                        <li class="chapter " data-level="1.1" data-path="https://naka1205.github.io/rpgsample/p/FEEC8D8FB78C0C58.html"><a href="https://naka1205.github.io/rpgsample/p/FEEC8D8FB78C0C58.html">何谓角色扮演游戏（RPG）</a></li>
                        <li class="chapter " data-level="1.2" data-path="https://naka1205.github.io/rpgsample/p/BC79B4D3134C347C.html"><a href="https://naka1205.github.io/rpgsample/p/BC79B4D3134C347C.html">RPG分类</a></li>
                        <li class="chapter " data-level="1.3" data-path="https://naka1205.github.io/rpgsample/p/F20DC96FA50A49C7.html"><a href="https://naka1205.github.io/rpgsample/p/F20DC96FA50A49C7.html">写RPG时的软硬件需求</a></li>
                    <li class="divider"></li>
                <li class="header">游戏系统的设计</li>
                        <li class="chapter " data-level="2.1" data-path="https://naka1205.github.io/rpgsample/p/057DE479BA15F0C2.html"><a href="https://naka1205.github.io/rpgsample/p/057DE479BA15F0C2.html">RPG系统</a></li>
                        <li class="chapter " data-level="2.2" data-path="https://naka1205.github.io/rpgsample/p/98A9BEB4C06AB6F5.html"><a href="https://naka1205.github.io/rpgsample/p/98A9BEB4C06AB6F5.html">RPG的必备功能和设计</a></li>
                    <li class="divider"></li>
                <li class="header">Windows程序设计</li>
                        <li class="chapter " data-level="3.1" data-path="https://naka1205.github.io/rpgsample/p/29DEF3B121E67E34.html"><a href="https://naka1205.github.io/rpgsample/p/29DEF3B121E67E34.html">游戏的必备功能</a></li>
                        <li class="chapter " data-level="3.2" data-path="https://naka1205.github.io/rpgsample/p/E250E5C20EC8FDF3.html"><a href="https://naka1205.github.io/rpgsample/p/E250E5C20EC8FDF3.html">开启窗口</a></li>
                        <li class="chapter " data-level="3.3" data-path="https://naka1205.github.io/rpgsample/p/7FA5E0693CC56877.html"><a href="https://naka1205.github.io/rpgsample/p/7FA5E0693CC56877.html">显示CG</a></li>
                        <li class="chapter " data-level="3.4" data-path="https://naka1205.github.io/rpgsample/p/FF11E655570F0335.html"><a href="https://naka1205.github.io/rpgsample/p/FF11E655570F0335.html">显示CG的应用软件</a></li>
                        <li class="chapter  active " data-level="3.5" data-path="https://naka1205.github.io/rpgsample/p/FD772D011D420B30.html"><a href="https://naka1205.github.io/rpgsample/p/FD772D011D420B30.html">CG/Sprite的重叠显示</a></li>
                        <li class="chapter " data-level="3.6" data-path="https://naka1205.github.io/rpgsample/p/9505172717587147.html"><a href="https://naka1205.github.io/rpgsample/p/9505172717587147.html">贴图零件(sprite)显示</a></li>
                    <li class="divider"></li>
                <li class="header">显示地图和人物</li>
                        <li class="chapter " data-level="4.1" data-path="https://naka1205.github.io/rpgsample/p/D669497E6697FA89.html"><a href="https://naka1205.github.io/rpgsample/p/D669497E6697FA89.html">地图坐标系</a></li>
                        <li class="chapter " data-level="4.2" data-path="https://naka1205.github.io/rpgsample/p/CB9C77BD644B1669.html"><a href="https://naka1205.github.io/rpgsample/p/CB9C77BD644B1669.html">Sprite的显示</a></li>
                        <li class="chapter " data-level="4.3" data-path="https://naka1205.github.io/rpgsample/p/D4F60F30B7F0944A.html"><a href="https://naka1205.github.io/rpgsample/p/D4F60F30B7F0944A.html">显示的程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">人物移动</li>
                        <li class="chapter " data-level="5.1" data-path="https://naka1205.github.io/rpgsample/p/9BDC29F23C108FCD.html"><a href="https://naka1205.github.io/rpgsample/p/9BDC29F23C108FCD.html">移动的思维方式</a></li>
                        <li class="chapter " data-level="5.2" data-path="https://naka1205.github.io/rpgsample/p/294F9E27361163C8.html"><a href="https://naka1205.github.io/rpgsample/p/294F9E27361163C8.html">移动的动画</a></li>
                        <li class="chapter " data-level="5.3" data-path="https://naka1205.github.io/rpgsample/p/850A8F5D7D49913A.html"><a href="https://naka1205.github.io/rpgsample/p/850A8F5D7D49913A.html">移动的程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">战斗</li>
                        <li class="chapter " data-level="6.1" data-path="https://naka1205.github.io/rpgsample/p/714FCCE62BEAE7EF.html"><a href="https://naka1205.github.io/rpgsample/p/714FCCE62BEAE7EF.html">读入地图数据</a></li>
                        <li class="chapter " data-level="6.2" data-path="https://naka1205.github.io/rpgsample/p/DE18A13DD466BCF5.html"><a href="https://naka1205.github.io/rpgsample/p/DE18A13DD466BCF5.html">战斗规则</a></li>
                        <li class="chapter " data-level="6.3" data-path="https://naka1205.github.io/rpgsample/p/372F73F2A1CBD002.html"><a href="https://naka1205.github.io/rpgsample/p/372F73F2A1CBD002.html">攻击时的动画</a></li>
                        <li class="chapter " data-level="6.4" data-path="https://naka1205.github.io/rpgsample/p/D6377D95C3DAE065.html"><a href="https://naka1205.github.io/rpgsample/p/D6377D95C3DAE065.html">魔法攻击的处理</a></li>
                        <li class="chapter " data-level="6.5" data-path="https://naka1205.github.io/rpgsample/p/84AF096B75C4D0F4.html"><a href="https://naka1205.github.io/rpgsample/p/84AF096B75C4D0F4.html">CPU端的思维模式</a></li>
                        <li class="chapter " data-level="6.6" data-path="https://naka1205.github.io/rpgsample/p/ECD1A205E33A1347.html"><a href="https://naka1205.github.io/rpgsample/p/ECD1A205E33A1347.html">CPU端人物的攻击</a></li>
                        <li class="chapter " data-level="6.7" data-path="https://naka1205.github.io/rpgsample/p/FAC327CB74DDD86D.html"><a href="https://naka1205.github.io/rpgsample/p/FAC327CB74DDD86D.html">执行程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">事件</li>
                        <li class="chapter " data-level="7.1" data-path="https://naka1205.github.io/rpgsample/p/9308712D0BA44B6C.html"><a href="https://naka1205.github.io/rpgsample/p/9308712D0BA44B6C.html">事件的执行方法</a></li>
                        <li class="chapter " data-level="7.2" data-path="https://naka1205.github.io/rpgsample/p/EA6BA727743E6636.html"><a href="https://naka1205.github.io/rpgsample/p/EA6BA727743E6636.html">命令的执行处理</a></li>
                        <li class="chapter " data-level="7.3" data-path="https://naka1205.github.io/rpgsample/p/1FD117B39A12879F.html"><a href="https://naka1205.github.io/rpgsample/p/1FD117B39A12879F.html">效果</a></li>
                    <li class="divider"></li>
                <li class="header">编辑参数</li>
                        <li class="chapter " data-level="8.1" data-path="https://naka1205.github.io/rpgsample/p/BE63E223F2902F52.html"><a href="https://naka1205.github.io/rpgsample/p/BE63E223F2902F52.html">参数</a></li>
                        <li class="chapter " data-level="8.2" data-path="https://naka1205.github.io/rpgsample/p/FCD874DB5CE467EB.html"><a href="https://naka1205.github.io/rpgsample/p/FCD874DB5CE467EB.html">参数编辑器</a></li>
                    <li class="divider"></li>
                <li class="header">大功告成</li>
                        <li class="chapter " data-level="9.1" data-path="https://naka1205.github.io/rpgsample/p/1107A00384B06596.html"><a href="https://naka1205.github.io/rpgsample/p/1107A00384B06596.html">增补其他功能</a></li>
                        <li class="chapter " data-level="9.2" data-path="https://naka1205.github.io/rpgsample/p/4E29E074EC583114.html"><a href="https://naka1205.github.io/rpgsample/p/4E29E074EC583114.html">从外部文件读入参数</a></li>
                        <li class="chapter " data-level="9.3" data-path="https://naka1205.github.io/rpgsample/p/466677A509CFE1D8.html"><a href="https://naka1205.github.io/rpgsample/p/466677A509CFE1D8.html">结合战斗部分和故事大纳</a></li>
                        <li class="chapter " data-level="9.4" data-path="https://naka1205.github.io/rpgsample/p/A7636FB800B97FD5.html"><a href="https://naka1205.github.io/rpgsample/p/A7636FB800B97FD5.html">播放音乐</a></li>
                        <li class="chapter " data-level="9.5" data-path="https://naka1205.github.io/rpgsample/p/6CB6CA31DF912DC1.html"><a href="https://naka1205.github.io/rpgsample/p/6CB6CA31DF912DC1.html">存储/装入</a></li>
                        <li class="chapter " data-level="9.6" data-path="https://naka1205.github.io/rpgsample/p/DFAF0C32BFFE733B.html"><a href="https://naka1205.github.io/rpgsample/p/DFAF0C32BFFE733B.html">播放音效</a></li>
                        <li class="chapter " data-level="9.7" data-path="https://naka1205.github.io/rpgsample/p/26C22A438848C588.html"><a href="https://naka1205.github.io/rpgsample/p/26C22A438848C588.html">提升等级</a></li>
                        <li class="chapter " data-level="9.8" data-path="https://naka1205.github.io/rpgsample/p/B5D1DD2411A4AD87.html"><a href="https://naka1205.github.io/rpgsample/p/B5D1DD2411A4AD87.html">直接跳跃</a></li>
                        <li class="chapter " data-level="9.9" data-path="https://naka1205.github.io/rpgsample/p/3F050F1718FBC3D8.html"><a href="https://naka1205.github.io/rpgsample/p/3F050F1718FBC3D8.html">故事大纲实例</a></li>
                    <li class="divider"></li>
                <li class="header">浅谈即时系统</li>
                        <li class="chapter " data-level="10.1" data-path="https://naka1205.github.io/rpgsample/p/3A99ECF04F2323C2.html"><a href="https://naka1205.github.io/rpgsample/p/3A99ECF04F2323C2.html">战略型即时系统的基本概念</a></li>
                    <li class="divider"></li>
                <li><a href="https://github.com/naka1205/pkbook" target="blank" class="gitbook-link">Published with PKBook</a></li>
    </ul>
</nav>
    </div>
    
    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
                <h1><i class="fa fa-circle-o-notch fa-spin"></i><a href="https://naka1205.github.io/rpgsample/p/FD772D011D420B30.html">CG/Sprite的重叠显示</a></h1>
            </div>
            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                    <div id="book-search-results">
                        <div class="search-noresults">
                            <section class="normal markdown-section">
                                <h3 id="CG%2FSprite%E7%9A%84%E9%87%8D%E5%8F%A0%E6%98%BE%E7%A4%BA" name="CG%2FSprite%E7%9A%84%E9%87%8D%E5%8F%A0%E6%98%BE%E7%A4%BA">CG/Sprite的重叠显示</h3>
<p>其实杀鸡焉用牛刀、各位不需要用到Windows功能就能自己处理CG重叠。不但变通性高,而且现在电脑的CPU的速度等级够快了,即使成果差强人意也应该能用才对。</p>
<p>重叠处理是要在内存上完成。如果等到显示时才重叠在一起,会变成两段式先“绘制背景”、再“绘制重叠的CG”,可能会只显示背景而已。</p>
<p>在合成背景和人物时,内存上必须保留“背景”、“人物”和“显示图形”这三个CG图像(假设现在想把另一个人物跟背景重叠时,只要内存一直保留着背景CG,就不需要重新读取CG到内存上)。当CG数据可以“用完就丢”,当然就不需要保留了,情况如图3-6所示。</p>
<h4 id="%E5%88%B6%E4%BD%9C%E5%90%88%E6%88%90%E7%94%A8%E7%9A%84%E7%B1%BB" name="%E5%88%B6%E4%BD%9C%E5%90%88%E6%88%90%E7%94%A8%E7%9A%84%E7%B1%BB">制作合成用的类</h4>
<p>合成的第一步是先把背景复制到显示用图像(内存),接着再跟人物合成。这两个动作需要有“复制”和“合成”的函数,我们就先动手做这两个函数吧。</p>
<p>有时直接把CDib类拿来用也不一定有好处。CDib类不会决定色彩,因此如果不让它能决定色彩的话,就必须设计一个“不受色彩影响”的函数。</p>
<p>还要按照8bpp、16bpp、24bpp的分类等级一设计其专用类,实在是工程浩大,而且实际上又不是每个都非要不可,所以我们选择继承CDib再设计一个24bpp专用的类。</p>
<p>合成用的类(Image.h/Image.cpp)则继承CDib,只修改必要的部分。</p>
<p>合成用类(Image.h)</p>
<pre><code class="C++">#ifndef __image_h
#define __image_h

#include "Dib.h"
#include "Misc.h"

class CDC;

//
//  专给24bit使用的CIB类
//
class CImage: public CDib {
  public:
    CImage(): CDib() {}
    CImage(int width, int height);

    BOOL Create(int width, int height);

    void Copy(const CImage *image, const CRect &amp;rect);
    void Copy(const CImage *image);
    void MixImage(const CImage *image, const CRect &amp;rect, COLORREF trans=RGB(0, 255, 0));
    void MixImage(const CImage *image, const CRect &amp;rect, CPoint src_pos, COLORREF trans=RGB(0, 255, 0));
} ;

//  inline 成员函数

inline void CImage::Copy(const CImage *image)
{
    Copy(image, CRect(0, 0, image-&gt;Width(), image-&gt;Height()));
}

#endif</code></pre>
<p>合成用类(Image.cpp)</p>
<pre><code class="C++">#include "StdAfx.h"
#include "Application.h"
#include "Image.h"
#include "File.h"
#include "Misc.h"
#include "dc.h"

//
// 构造函数
//
CImage::CImage(int width, int height)
{
    Create(width, height);
}

//
// 产生DIB
//
BOOL CImage::Create(int width, int height)
{
    return CDib::Create(width, height, 24);
}

//
// 复制区域
//
void CImage::Copy(const CImage *image, const CRect &amp;rect)
{
    int     len = rect.Width() * 3;
    for (int y=rect.top; y&lt;rect.bottom; y++) {
        memcpy(GetBits(rect.left, y), image-&gt;GetBits(rect.left, y), len);
    }
}

//
// 复制（考虑了透明颜色）
//
void CImage::MixImage(const CImage *image, const CRect &amp;rect, COLORREF trans_color)
{
    const unsigned char trans_b = GetBValue(trans_color);
    const unsigned char trans_g = GetGValue(trans_color);
    const unsigned char trans_r = GetRValue(trans_color);

    for (int y=rect.top; y&lt;rect.bottom; y++) {
        byte_t *p = (byte_t *)GetBits(rect.left, y);
        const byte_t *q = (byte_t *)image-&gt;GetBits(rect.left, y);
        for (int x=rect.left; x&lt;rect.right; x++) {
            const byte_t b = *q++;
            const byte_t g = *q++;
            const byte_t r = *q++;

            if (b != trans_b || g != trans_g || r != trans_r) {
                p[0] = b;
                p[1] = g;
                p[2] = r;
            }
            p += 3;
        }
    }
}</code></pre>
<h5 id="%E5%A4%8D%E5%88%B6%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0" name="%E5%A4%8D%E5%88%B6%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0">复制用的函数</h5>
<p>虽然讲是讲“图形”,不过其实是内存上的数据,因此复制的动作可使用"memcpy"。</p>
<pre><code class="C++">//
// 复制区域
//
void CImage::Copy(const CImage *image, const CRect &amp;rect)
{
    int     len = rect.Width() * 3;
    for (int y=rect.top; y&lt;rect.bottom; y++) {
        memcpy(GetBits(rect.left, y), image-&gt;GetBits(rect.left, y), len);
    }
}</code></pre>
<p>宽度的地方乘以“3”是因为“1像素=3byte”的关系。不断复制必须要的高度,即可复制图形。</p>
<h5 id="%E5%90%88%E6%88%90%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0" name="%E5%90%88%E6%88%90%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0">合成用的函数</h5>
<p>合成的过程中必须制定出一个规则,否则程序无法判断哪些部分要合成、哪些部分又不需要合成,当然就不会进行复制。这个判断的方法必须要弄清。</p>
<p>说穿了,就是提供“遮罩图形”的方法和设定“透明色彩”的方法。</p>
<p>如欲使用遮罩图形,则需另行制作遮罩用的图形,所以CG制作比较麻烦。这里是使用透明色彩来进行合成。</p>
<p>至于透明色彩的选择方式,最常使用的是“RGB(0,255,0)”的“亮绿色”当然也可以自定义其他色彩,不过最好是“非常极端、CG不会用到的色彩”。</p>
<pre><code class="C++">const byte_t b = *q++;  //蓝
const byte_t g = *q++;  //绿
const byte_t r = *q++;  //红

if (b != trans_b || g != trans_g || r != trans_r) {
    p[0] = b;
    p[1] = g;
    p[2] = r;
}
p += 3;</code></pre>
<p>合成处理是先在循环中逐一判断各个像素是“透明色彩”或“非透明色彩”,若为“非透明色彩”则进行复制。</p>
<p>如果不控制DIB的色彩数量,这个处理动作会越变越复杂,因此这里设限为24bpp。若为16bpp或32bpp,则须另外设计其他适合的常数。</p>
<h4 id="DDIBSection" name="DDIBSection">DDIBSection</h4>
<p>这里的DIBSection是要用在显示用图像的部分,DIBSection也是先在内存上完成合成处理之后,再显示到画面上。</p>
<p>DIBSection(Drawlmage.h)</p>
<pre><code class="C++">#ifndef __DrawImage_h__
#define __DrawImage_h__

#include "Image.h"
#include "Misc.h"

//
//  使用DIB section的24bit的DIB类
//
class CDrawImage: public CImage {
  public:
    CDrawImage();
    ~CDrawImage();

    BOOL Create(HDC dc, int width, int height);

    void Draw(HDC dc, int x, int y, int w, int h, int ox=0, int oy=0);
    void Draw(HDC dc, const CRect &amp;rect, CPoint point);
    void Draw(HDC dc, const CRect &amp;rect);

    HBITMAP GetBitmapHandle() const { return hBitmap; }

  protected:
    BITMAPINFOHEADER InfoHeader;
    HBITMAP hBitmap;
} ;

//  inline 成员函数

//  绘制
//
//  虽然有3种，但除了引数型态不一样之外，动作均同
//
inline void CDrawImage::Draw(HDC dc, int x, int y, int w, int h, int ox, int oy)
{
    HDC memdc = CreateCompatibleDC(dc);
    HGDIOBJ oldbmp = SelectObject(memdc, hBitmap);
    BitBlt(dc, x, y, w, h, memdc, ox, oy, SRCCOPY);
    GdiFlush();
    SelectObject(memdc, oldbmp);
    DeleteDC(memdc);
}

inline void CDrawImage::Draw(HDC dc, const CRect &amp;rect, CPoint point)
{
    Draw(dc, rect.left, rect.top, rect.Width(), rect.Height(), point.x, point.y);
}

inline void CDrawImage::Draw(HDC dc, const CRect &amp;rect)
{
    Draw(dc, rect.left, rect.top, rect.Width(), rect.Height(), rect.left, rect.top);
}

#endif</code></pre>
<p>DIBSection(Drawlmage.cpp)</p>
<pre><code class="C++">#include "StdAfx.h"
#include "DrawImage.h"
#include "dc.h"
#include "Misc.h"

//
// 构造函数
//
CDrawImage::CDrawImage()
    :CImage(), hBitmap(0)
{
}

//
// 析构函数
//
CDrawImage::~CDrawImage()
{
    GdiFlush();
    if (hBitmap) {
        ::DeleteObject(hBitmap);
    }
}

//
// 产生DIB section
//
BOOL CDrawImage::Create(HDC dc, int width, int height)
{
    W = width;
    H = height;
    D = 24;

    bytes_per_line = ScanBytes(width, 24);
    bytes_per_pixel = PixelBytes(24);

    InfoHeader.biSize           = sizeof(BITMAPINFOHEADER);
    InfoHeader.biWidth          = width;
    InfoHeader.biHeight         = height;
    InfoHeader.biBitCount       = 24;
    InfoHeader.biPlanes         = 1;
    InfoHeader.biXPelsPerMeter  = 0;
    InfoHeader.biYPelsPerMeter  = 0;
    InfoHeader.biClrUsed        = 0;
    InfoHeader.biClrImportant   = 0;
    InfoHeader.biCompression    = BI_RGB;
    InfoHeader.biSizeImage      = bytes_per_line * height;

    Info = (BITMAPINFO *)&amp;InfoHeader;
    hBitmap = CreateDIBSection(dc, Info, DIB_RGB_COLORS, &amp;Bits, NULL, 0);

    return hBitmap != 0;
}</code></pre>
<p>这里是利用CreateDIBSection产生DIBSection。</p>
<pre><code class="C++">CreateDIBSection(
HDC               hdc,      //装置构造画款的处理常数
CONST BITMAPINFO *pbmi,     //点阵图载据
UINT              usage,    //各种数据的标识持
VOID            **ppvBits,  //位元值
HANDLE            hSection, //文件映射对象的处理常数
DWORD             dwOffset);    //分支到点阵图的位置</code></pre>
<p>在上面的实例中,设备构造函数(HDC)会传递出窗口的HDC。因为就算不是欲绘制的窗口也没关系,只要同一设备即可,所以screenDC也是相同的结果。</p>
<p>点阵图数据的内容则同产生DIB时的BITMAPINFO。</p>
<pre><code class="C++">    InfoHeader.biSize           = sizeof(BITMAPINFOHEADER);
    InfoHeader.biWidth          = width;
    InfoHeader.biHeight         = height;
    InfoHeader.biBitCount       = 24;
    InfoHeader.biPlanes         = 1;
    InfoHeader.biXPelsPerMeter  = 0;
    InfoHeader.biYPelsPerMeter  = 0;
    InfoHeader.biClrUsed        = 0;
    InfoHeader.biClrImportant   = 0;
    InfoHeader.biCompression    = BI_RGB;
    InfoHeader.biSizeImage      = bytes_per_line * height;

    Info = (BITMAPINFO *)&amp;InfoHeader;
    hBitmap = CreateDIBSection(dc, Info, DIB_RGB_COLORS, &amp;Bits, NULL, 0);</code></pre>
<p>如此一来,在“Bits”就会得到指向保留内存的指针。
这样看起来,好像跟DIB没什么两样,但两者最大的差异是在得到的返回值为HBITMAP。</p>
<h4 id="ODIBSection%E7%9A%84%E7%BB%98%E5%88%B6" name="ODIBSection%E7%9A%84%E7%BB%98%E5%88%B6">ODIBSection的绘制</h4>
<p>DIBSection也是一种DIB,因此当然可以用SetDIBitsToDevice进行绘制,不过反正都已经有DDB(BITMAP)了,利用BitBlt也同样能进行绘制(这里可能有点不容易懂...)。</p>
<p>利用BitBlt进行绘制时,则为:</p>
<pre><code class="C++">inline void CDrawImage::Draw(HDC dc, int x, int y, int w, int h, int ox, int oy)
{
    HDC memdc = CreateCompatibleDC(dc);
    HGDIOBJ oldbmp = SelectObject(memdc, hBitmap);
    BitBlt(dc, x, y, w, h, memdc, ox, oy, SRCCOPY);
    GdiFlush();
    SelectObject(memdc, oldbmp);
    DeleteDC(memdc);
}</code></pre>
<p>BitBlt有固定的使用步骤,所以先做成函数。这个步骤程序是最典型使用BitBIt的例子,早点背起来有好处的!</p>
<p>图形合成的相关实例放在本书随附光盘的文件夹“chapter3.2”下。如图3-8所示,如果只看程序执行,恐怕不太容易看出来整个合成过程,该文件夹下还有背景BMP文件和人物的BMP文件,各位同时交叉参考这些图像文件就能了解“合成显示”的意思了。</p>                            </section>
                        </div>
                        <div class="search-results">
                            <div class="has-results">
                                <h1 class="search-results-title">
                                    关于"<span class='search-query'></span>"的搜索结果共<span class='search-results-count'></span>条
                                </h1>
                                <ul class="search-results-list"></ul>
                            </div>
                            <div class="no-results">
                                <h1 class="search-results-title">没有"<span class='search-query'></span>"相关内容</h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                <a href="https://naka1205.github.io/rpgsample/p/FF11E655570F0335.html" class="navigation navigation-prev " aria-label="显示CG的应用软件">
            <i class="fa fa-angle-left"></i>
        </a>
                <a href="https://naka1205.github.io/rpgsample/p/9505172717587147.html" class="navigation navigation-next " aria-label="贴图零件(sprite)显示">
            <i class="fa fa-angle-right"></i>
        </a>
               
    </div>
<script>
var gitbook = gitbook || [];
gitbook.push(function() {
    gitbook.page.hasChanged({
        "page": {
            "title":  "CG/Sprite的重叠显示",
            "next": {
                "title": "贴图零件(sprite)显示"
            },
            "previous": {
                "title": "显示CG的应用软件"
            }
        },
        "config": {
            "gitbook": "*",
            "theme": "default",
            "variables": {},
            "plugins": ["-lunr", "-search", "-highlight","search-pro"],
            "pluginsConfig": {
                "search-pro": {},
                "highlight": {},
                "sharing": {},
                "fontsettings": {},
                "theme-default": {}
            },
            "structure": {},
            "pdf": {},
            "styles": {}
        },
        "file": {},
        "gitbook": {},
        "basePath": "https://naka1205.github.io/rpgsample",
        "book": {}
    });
});
</script>
</div>
<script src="https://naka1205.github.io/rpgsample/assets/js/gitbook.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/theme.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/jquery.mark.min.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/search.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/buttons.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/fontsettings.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/plugin.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
</body>
</html>