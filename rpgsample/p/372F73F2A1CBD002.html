<!DOCTYPE HTML>
<html lang=""> 
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>攻击时的动画 · C++实例教程</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="description" content="攻击的处理动作分析起来,其实也只有计算破环力+HP一破坏力-若HP为“0”则离开战场而已。要是除了计算之外都没有其他动作,稍微有点单调,而且如果只有状态显示部分的HP减少的话,游戏玩家也不太容易了解自己刚刚做了什么动作(或是有人对他做了什么动作)。就像人物走动一样,攻击时也需要有动画才能衬托出有动作的感觉。">
    <meta name="keywords" content="角色扮演 教程">
    <meta name="generator" content="PKBook">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/style.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/search.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/ebook.css">
    <link rel="stylesheet" href="https://naka1205.github.io/rpgsample/assets/css/website.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/github.min.css" rel="stylesheet">
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://naka1205.github.io/rpgsample/assets/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://naka1205.github.io/rpgsample/assets/images/favicon.ico" type="image/x-icon">
</head>
<body>
<div class="book">
    <div class="book-summary">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="输入关键词搜索" />
        </div>
        <nav role="navigation">
    <ul class="summary">
        <li><a href="https://naka1205.github.io/rpgsample/index.html" target="blank" class="header">说明</a></li>
        <li class="divider"></li>
                <li class="header">写一个角色扮演游戏</li>
                        <li class="chapter " data-level="1.1" data-path="https://naka1205.github.io/rpgsample/p/FEEC8D8FB78C0C58.html"><a href="https://naka1205.github.io/rpgsample/p/FEEC8D8FB78C0C58.html">何谓角色扮演游戏（RPG）</a></li>
                        <li class="chapter " data-level="1.2" data-path="https://naka1205.github.io/rpgsample/p/BC79B4D3134C347C.html"><a href="https://naka1205.github.io/rpgsample/p/BC79B4D3134C347C.html">RPG分类</a></li>
                        <li class="chapter " data-level="1.3" data-path="https://naka1205.github.io/rpgsample/p/F20DC96FA50A49C7.html"><a href="https://naka1205.github.io/rpgsample/p/F20DC96FA50A49C7.html">写RPG时的软硬件需求</a></li>
                    <li class="divider"></li>
                <li class="header">游戏系统的设计</li>
                        <li class="chapter " data-level="2.1" data-path="https://naka1205.github.io/rpgsample/p/057DE479BA15F0C2.html"><a href="https://naka1205.github.io/rpgsample/p/057DE479BA15F0C2.html">RPG系统</a></li>
                        <li class="chapter " data-level="2.2" data-path="https://naka1205.github.io/rpgsample/p/98A9BEB4C06AB6F5.html"><a href="https://naka1205.github.io/rpgsample/p/98A9BEB4C06AB6F5.html">RPG的必备功能和设计</a></li>
                    <li class="divider"></li>
                <li class="header">Windows程序设计</li>
                        <li class="chapter " data-level="3.1" data-path="https://naka1205.github.io/rpgsample/p/29DEF3B121E67E34.html"><a href="https://naka1205.github.io/rpgsample/p/29DEF3B121E67E34.html">游戏的必备功能</a></li>
                        <li class="chapter " data-level="3.2" data-path="https://naka1205.github.io/rpgsample/p/E250E5C20EC8FDF3.html"><a href="https://naka1205.github.io/rpgsample/p/E250E5C20EC8FDF3.html">开启窗口</a></li>
                        <li class="chapter " data-level="3.3" data-path="https://naka1205.github.io/rpgsample/p/7FA5E0693CC56877.html"><a href="https://naka1205.github.io/rpgsample/p/7FA5E0693CC56877.html">显示CG</a></li>
                        <li class="chapter " data-level="3.4" data-path="https://naka1205.github.io/rpgsample/p/FF11E655570F0335.html"><a href="https://naka1205.github.io/rpgsample/p/FF11E655570F0335.html">显示CG的应用软件</a></li>
                        <li class="chapter " data-level="3.5" data-path="https://naka1205.github.io/rpgsample/p/FD772D011D420B30.html"><a href="https://naka1205.github.io/rpgsample/p/FD772D011D420B30.html">CG/Sprite的重叠显示</a></li>
                        <li class="chapter " data-level="3.6" data-path="https://naka1205.github.io/rpgsample/p/9505172717587147.html"><a href="https://naka1205.github.io/rpgsample/p/9505172717587147.html">贴图零件(sprite)显示</a></li>
                    <li class="divider"></li>
                <li class="header">显示地图和人物</li>
                        <li class="chapter " data-level="4.1" data-path="https://naka1205.github.io/rpgsample/p/D669497E6697FA89.html"><a href="https://naka1205.github.io/rpgsample/p/D669497E6697FA89.html">地图坐标系</a></li>
                        <li class="chapter " data-level="4.2" data-path="https://naka1205.github.io/rpgsample/p/CB9C77BD644B1669.html"><a href="https://naka1205.github.io/rpgsample/p/CB9C77BD644B1669.html">Sprite的显示</a></li>
                        <li class="chapter " data-level="4.3" data-path="https://naka1205.github.io/rpgsample/p/D4F60F30B7F0944A.html"><a href="https://naka1205.github.io/rpgsample/p/D4F60F30B7F0944A.html">显示的程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">人物移动</li>
                        <li class="chapter " data-level="5.1" data-path="https://naka1205.github.io/rpgsample/p/9BDC29F23C108FCD.html"><a href="https://naka1205.github.io/rpgsample/p/9BDC29F23C108FCD.html">移动的思维方式</a></li>
                        <li class="chapter " data-level="5.2" data-path="https://naka1205.github.io/rpgsample/p/294F9E27361163C8.html"><a href="https://naka1205.github.io/rpgsample/p/294F9E27361163C8.html">移动的动画</a></li>
                        <li class="chapter " data-level="5.3" data-path="https://naka1205.github.io/rpgsample/p/850A8F5D7D49913A.html"><a href="https://naka1205.github.io/rpgsample/p/850A8F5D7D49913A.html">移动的程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">战斗</li>
                        <li class="chapter " data-level="6.1" data-path="https://naka1205.github.io/rpgsample/p/714FCCE62BEAE7EF.html"><a href="https://naka1205.github.io/rpgsample/p/714FCCE62BEAE7EF.html">读入地图数据</a></li>
                        <li class="chapter " data-level="6.2" data-path="https://naka1205.github.io/rpgsample/p/DE18A13DD466BCF5.html"><a href="https://naka1205.github.io/rpgsample/p/DE18A13DD466BCF5.html">战斗规则</a></li>
                        <li class="chapter  active " data-level="6.3" data-path="https://naka1205.github.io/rpgsample/p/372F73F2A1CBD002.html"><a href="https://naka1205.github.io/rpgsample/p/372F73F2A1CBD002.html">攻击时的动画</a></li>
                        <li class="chapter " data-level="6.4" data-path="https://naka1205.github.io/rpgsample/p/D6377D95C3DAE065.html"><a href="https://naka1205.github.io/rpgsample/p/D6377D95C3DAE065.html">魔法攻击的处理</a></li>
                        <li class="chapter " data-level="6.5" data-path="https://naka1205.github.io/rpgsample/p/84AF096B75C4D0F4.html"><a href="https://naka1205.github.io/rpgsample/p/84AF096B75C4D0F4.html">CPU端的思维模式</a></li>
                        <li class="chapter " data-level="6.6" data-path="https://naka1205.github.io/rpgsample/p/ECD1A205E33A1347.html"><a href="https://naka1205.github.io/rpgsample/p/ECD1A205E33A1347.html">CPU端人物的攻击</a></li>
                        <li class="chapter " data-level="6.7" data-path="https://naka1205.github.io/rpgsample/p/FAC327CB74DDD86D.html"><a href="https://naka1205.github.io/rpgsample/p/FAC327CB74DDD86D.html">执行程序实例</a></li>
                    <li class="divider"></li>
                <li class="header">事件</li>
                        <li class="chapter " data-level="7.1" data-path="https://naka1205.github.io/rpgsample/p/9308712D0BA44B6C.html"><a href="https://naka1205.github.io/rpgsample/p/9308712D0BA44B6C.html">事件的执行方法</a></li>
                        <li class="chapter " data-level="7.2" data-path="https://naka1205.github.io/rpgsample/p/EA6BA727743E6636.html"><a href="https://naka1205.github.io/rpgsample/p/EA6BA727743E6636.html">命令的执行处理</a></li>
                        <li class="chapter " data-level="7.3" data-path="https://naka1205.github.io/rpgsample/p/1FD117B39A12879F.html"><a href="https://naka1205.github.io/rpgsample/p/1FD117B39A12879F.html">效果</a></li>
                    <li class="divider"></li>
                <li class="header">编辑参数</li>
                        <li class="chapter " data-level="8.1" data-path="https://naka1205.github.io/rpgsample/p/BE63E223F2902F52.html"><a href="https://naka1205.github.io/rpgsample/p/BE63E223F2902F52.html">参数</a></li>
                        <li class="chapter " data-level="8.2" data-path="https://naka1205.github.io/rpgsample/p/FCD874DB5CE467EB.html"><a href="https://naka1205.github.io/rpgsample/p/FCD874DB5CE467EB.html">参数编辑器</a></li>
                    <li class="divider"></li>
                <li class="header">大功告成</li>
                        <li class="chapter " data-level="9.1" data-path="https://naka1205.github.io/rpgsample/p/1107A00384B06596.html"><a href="https://naka1205.github.io/rpgsample/p/1107A00384B06596.html">增补其他功能</a></li>
                        <li class="chapter " data-level="9.2" data-path="https://naka1205.github.io/rpgsample/p/4E29E074EC583114.html"><a href="https://naka1205.github.io/rpgsample/p/4E29E074EC583114.html">从外部文件读入参数</a></li>
                        <li class="chapter " data-level="9.3" data-path="https://naka1205.github.io/rpgsample/p/466677A509CFE1D8.html"><a href="https://naka1205.github.io/rpgsample/p/466677A509CFE1D8.html">结合战斗部分和故事大纳</a></li>
                        <li class="chapter " data-level="9.4" data-path="https://naka1205.github.io/rpgsample/p/A7636FB800B97FD5.html"><a href="https://naka1205.github.io/rpgsample/p/A7636FB800B97FD5.html">播放音乐</a></li>
                        <li class="chapter " data-level="9.5" data-path="https://naka1205.github.io/rpgsample/p/6CB6CA31DF912DC1.html"><a href="https://naka1205.github.io/rpgsample/p/6CB6CA31DF912DC1.html">存储/装入</a></li>
                        <li class="chapter " data-level="9.6" data-path="https://naka1205.github.io/rpgsample/p/DFAF0C32BFFE733B.html"><a href="https://naka1205.github.io/rpgsample/p/DFAF0C32BFFE733B.html">播放音效</a></li>
                        <li class="chapter " data-level="9.7" data-path="https://naka1205.github.io/rpgsample/p/26C22A438848C588.html"><a href="https://naka1205.github.io/rpgsample/p/26C22A438848C588.html">提升等级</a></li>
                        <li class="chapter " data-level="9.8" data-path="https://naka1205.github.io/rpgsample/p/B5D1DD2411A4AD87.html"><a href="https://naka1205.github.io/rpgsample/p/B5D1DD2411A4AD87.html">直接跳跃</a></li>
                        <li class="chapter " data-level="9.9" data-path="https://naka1205.github.io/rpgsample/p/3F050F1718FBC3D8.html"><a href="https://naka1205.github.io/rpgsample/p/3F050F1718FBC3D8.html">故事大纲实例</a></li>
                    <li class="divider"></li>
                <li class="header">浅谈即时系统</li>
                        <li class="chapter " data-level="10.1" data-path="https://naka1205.github.io/rpgsample/p/3A99ECF04F2323C2.html"><a href="https://naka1205.github.io/rpgsample/p/3A99ECF04F2323C2.html">战略型即时系统的基本概念</a></li>
                    <li class="divider"></li>
                <li><a href="https://github.com/naka1205/pkbook" target="blank" class="gitbook-link">Published with PKBook</a></li>
    </ul>
</nav>
    </div>
    
    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
                <h1><i class="fa fa-circle-o-notch fa-spin"></i><a href="https://naka1205.github.io/rpgsample/p/372F73F2A1CBD002.html">攻击时的动画</a></h1>
            </div>
            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                    <div id="book-search-results">
                        <div class="search-noresults">
                            <section class="normal markdown-section">
                                <h3 id="%E6%94%BB%E5%87%BB%E6%97%B6%E7%9A%84%E5%8A%A8%E7%94%BB" name="%E6%94%BB%E5%87%BB%E6%97%B6%E7%9A%84%E5%8A%A8%E7%94%BB">攻击时的动画</h3>
<p>攻击的处理动作分析起来,其实也只有计算破环力+HP一破坏力-若HP为“0”则离开战场而已。要是除了计算之外都没有其他动作,稍微有点单调,而且如果只有状态显示部分的HP减少的话,游戏玩家也不太容易了解自己刚刚做了什么动作(或是有人对他做了什么动作)。就像人物走动一样,攻击时也需要有动画才能衬托出有动作的感觉。</p>
<h4 id="%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%BC%8F" name="%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%BC%8F">动画模式</h4>
<p>动画模式要有攻击时和被攻击时这两种模式,图6-2是攻击时的模式。</p>
<p>如果你想根据攻击方式变化动画模式,CG模式的使用量会随之水涨船高。设计游戏时没有考虑到攻击模式而盲目增加CG时,小心会被CG设计师响咕到臭头!</p>
<p>除了攻击之类的动画,像是以动画的方式把破坏力显示在人物身上也是很常见的手法,如图6-3所示。</p>
<p>如欲以数字表示破坏力的大小,从“0”到最大破坏力的所有数字都得要有的话可能会没完没了,因此只设计了0~9的数字,写程序时再组合显示。</p>
<p>以程序编写的方式组合数字时,选择“宽度一致的字型”会比较好处理,在设计这些数字或字符时要记得保持宽度相同。</p>
<h4 id="%E6%94%BB%E5%87%BB%E5%A4%84%E7%90%86%E7%9A%84%E6%AD%A5%E9%AA%A4" name="%E6%94%BB%E5%87%BB%E5%A4%84%E7%90%86%E7%9A%84%E6%AD%A5%E9%AA%A4">攻击处理的步骤</h4>
<p>在处理有动画效果的攻击时,其处理步骤如下:</p>
<ul>
<li>搜寻/显示攻击范围</li>
<li>设定攻击目标</li>
<li>攻击的动画</li>
<li>HIT的动画</li>
<li>破坏力数值的动画</li>
<li>若HP为“0”,则将人物从地图上删除</li>
<li>更新显示状态</li>
</ul>
<p>首先,搜寻并显示可能的攻击范围。搜寻攻击范围是利用判断函数"MapData::ChkAttack"。</p>
<p>搜寻攻击范围(Battle.cpp)</p>
<pre><code class="C++">// 搜寻攻击范围
void CBattleAction::FindAttack(int x, int y, int dist, bool first)
{
    if (!first) {
        AddDistCursor(x, y, dist, 1);
        map_data[y][x].type |= ATTACKDIST;
        map_data[y][x].attack_dist = dist;
    }
    if (dist == 0)
        return;
    if (y &gt; MapRect.top &amp;&amp; map_data[y - 1][x].ChkAttack(dist))
        FindAttack(x, y - 1, dist - 1, false);
    if (y &lt; MapRect.bottom - 1 &amp;&amp; map_data[y + 1][x].ChkAttack(dist))
        FindAttack(x, y + 1, dist - 1, false);
    if (x &gt; MapRect.left &amp;&amp; map_data[y][x - 1].ChkAttack(dist))
        FindAttack(x - 1, y, dist - 1, false);
    if (x &lt; MapRect.right - 1 &amp;&amp; map_data[y][x + 1].ChkAttack(dist))
        FindAttack(x + 1, y, dist - 1, false);
}</code></pre>
<p>逻辑的部分跟搜寻移动范围时一样,如需说明请自行查阅。
这里是根据游戏玩家的鼠标指示而设定攻击目标,故需有一个鼠标输入的处理。请在<code>CBattleAction::LButtonDown</code>加入下面的处理动作。</p>
<p>设定攻击目标(Battle.cpp)</p>
<pre><code class="C++">case STATUS_ATTACK:
// 已点选攻击目标
if (MapRect.PtInRect(pos)
                &amp;&amp; (map_data[pos.y][pos.x].type &amp; (ATTACKDIST | ENEMY))
                     == (ATTACKDIST | ENEMY)) {
    Attack(SelChar, (CCharacter *)map_data[pos.y][pos.x].sprite, true);
    SelChar-&gt;attack_done = true;
}
break;</code></pre>
<p>当“在可能的攻击范围内有敌人”时,则“(map_data[y][x].type(ATTACKDIST | ENEMY)) == (ATTACKDIST | ENEMY)”为“真”。只要一点选这些位置,就会调用Attack函数。</p>
<p>因为动画使用计时器,就可以细分动作。先把整个动作分成3大部分,再依序调用。Attack是攻击的“第一阶段”。</p>
<p>启动攻击动画(Battle.cpp)</p>
<pre><code class="C++">// 攻击
void CBattleAction::Attack(CCharacter *from, CCharacter *to, bool player)
{
    // 删除光标
    SetCursor(CPoint(-1, -1));

    // 删除范围显示
    ClearDistCursor();
    CPoint pos = from-&gt;GetMapPoint();
    map_data[pos.y][pos.x].type &amp;= ~ATTACKDIST;
    map_data[pos.y][pos.x].attack_dist = 0;

    CSize diff = from-&gt;GetMapPoint() - to-&gt;GetMapPoint();

    // 调整人物方向
    if (abs(diff.cx) &gt; abs(diff.cy)) {
        if (diff.cx &lt; 0) {
            from-&gt;SetDirection(CCharacter::RIGHT);
            to-&gt;SetDirection(CCharacter::LEFT);
        }
        else {
            from-&gt;SetDirection(CCharacter::LEFT);
            to-&gt;SetDirection(CCharacter::RIGHT);
        }
    }
    else {
        if (diff.cy &lt; 0) {
            from-&gt;SetDirection(CCharacter::DOWN);
            to-&gt;SetDirection(CCharacter::UP);
        }
        else {
            from-&gt;SetDirection(CCharacter::UP);
            to-&gt;SetDirection(CCharacter::DOWN);
        }
    }
    RedrawSprite(from);
    RedrawSprite(to);

    // 攻击动画开始
    AttackFrom = from;
    AttackTo = to;
    AttackPlayerToEnemy = player;
    AttackAnimeCount = 0;

    status = STATUS_ANIME;
    Parent-&gt;SetTimer(TIMER_ATTACK_ID, TIMER_ATTACK_TIME);
}</code></pre>
<p>如果在第一阶段删除攻击范围的显示后,就马上攻击旁边或后面的敌人会不符常理,所以要记得让所有人物面对面。</p>
<p>这里也有调整被攻击方的方向,不过不改变对方方向、从后面突袭的做法好像也很有意思(甚至可以再加入一个背后攻击时则提高破坏力的处理)。接着再设定动画的相关变量,启动计时器,下面例子是计时器当中的攻击部分。</p>
<p>计时器的攻击部分(Battle.cpp)</p>
<pre><code class="C++">//
// 计时器的处理
//
bool CBattleAction::TimedOut(int timerId)
{
    switch (timerId) {
      case TIMER_ATTACK_ID: //攻击动画
        ASSERT(status == STATUS_ANIME);

        if (AttackAnimeCount &lt; CCharacter::ATTACK_STEP) {
            AttackFrom-&gt;AttackAnime(AttackAnimeCount++);
            RedrawSprite(AttackFrom);
        }
        else if (AttackAnimeCount &lt; CCharacter::ATTACK_STEP + CCharacter::HIT_STEP) {
            AttackTo-&gt;HitAnime(AttackAnimeCount++ - CCharacter::ATTACK_STEP);
            RedrawSprite(AttackTo);
        }
        else {
            AttackFrom-&gt;NormalStatus();
            AttackTo-&gt;NormalStatus();
            RedrawSprite(AttackFrom);
            RedrawSprite(AttackTo);

            AttackPhase2();
            return true;
        }
        break;
    }
}</code></pre>
<p>第一个启动的是攻方的动画(AttackAnime)。攻方动画结束后,再启动被攻击一方的动画(HitAnime)。被攻击方的动画结束后,人物的CG则恢复到“一般状态”,前往攻击的第2阶段(AttackPhase2)。</p>
<p>攻击的第2阶段(Battle.cpp)</p>
<pre><code class="C++">// 攻击阶段2
void CBattleAction::AttackPhase2()
{
    // 判断攻击
    // debug用，追踪变量
    TRACE("攻方参数:[%s]\n", AttackFrom-&gt;status.name);
    TRACE(" 攻击力 : %4d\n", AttackFrom-&gt;status.attack_power);
    TRACE(" 防御力 : %4d\n", AttackFrom-&gt;status.defence_power);
    TRACE(" 剩余HP : %4d\n", AttackFrom-&gt;status.hit_point);
    TRACE("守方参数:[%s]\n", AttackTo-&gt;status.name);
    TRACE(" 攻击力 : %4d\n", AttackTo-&gt;status.attack_power);
    TRACE(" 防御力 : %4d\n", AttackTo-&gt;status.defence_power);
    TRACE(" 剩余HP : %4d\n", AttackTo-&gt;status.hit_point);

    // 这个方法只用来计算而已，并没有使用乱数。
    // 破坏力 = 攻方攻击力 * 攻方攻击力 / 守方攻击力
    int ap = AttackFrom-&gt;status.attack_power;
    int dp = AttackTo-&gt;status.defence_power == 0? 1: AttackTo-&gt;status.defence_power;
    int attack = ap * ap / dp;
    if (attack &lt;= 0)    // 最低1点就有破坏力
        attack = 1;

    // 显示破坏力
    char damage[8];
    NumberView = sprintf(damage, "%d", attack);
    CPoint view = AttackTo-&gt;GetDrawPos();
    view.x += (AttackTo-&gt;GetSize().cx - NumberView * 8) / 2;
    view.y -= 12;
    for (int i=0; i&lt;NumberView; i++) {
        damage[i] -= '0';
        Number[i].Set(&amp;PopupParts, view, CPoint(damage[i] * 8, 0), CSize(8, 10), 0);
        view.x += 8;
        RedrawSprite(Number + i);
    }

    if (attack &gt; AttackTo-&gt;status.hit_point)
        attack = AttackTo-&gt;status.hit_point;

    TRACE(" 破坏力 : %4d\n", attack);

    AttackTo-&gt;status.hit_point -= attack;

    TRACE(" 剩余HP : %4d\n", AttackTo-&gt;status.hit_point);

    // 计算经验值
    // 每次攻击就有基本 10 point，若被打败倒地则+20 point
    // 如果有等级差距时
    // 攻方等级 ＞ 守方等级  减低所获得的经验值
    // 攻方等级 ＜ 守方等级  提高所获得的经验值
    int experience = 10;
    if (AttackTo-&gt;status.hit_point == 0)
        experience += 20;
    int level_diff = AttackFrom-&gt;status.level - AttackTo-&gt;status.level;
    if (level_diff &gt; 0) {   // 攻击较弱的对手
        experience &gt;&gt;= level_diff;
    }
    else if (level_diff) {
        experience &lt;&lt;= -level_diff;
    }

    TRACE(" 经验值 = %d + %d = %d\n",
        AttackFrom-&gt;status.experience, experience,
        AttackFrom-&gt;status.experience + experience);

    AttackFrom-&gt;status.experience += experience;

    // 破坏力的显示开始
    AttackAnimeCount = 0;
    status = STATUS_ANIME;
    Parent-&gt;SetTimer(TIMER_NUMBER_ID, TIMER_NUMBER_TIME);
}</code></pre>
<p>攻击的第二阶段是计算破坏力,并设定显示破坏力的sprite。</p>
<p>显示破坏力的sprite(Number)是一个数组,所有字符都分开来。如果要用2个字,两个字符一起动时看起来就像是完整的数字。</p>
<p>关于计算的部分,经验值也是在这里计算。经验值的求法即如源代码中的注释所示。</p>
<p>在此须根据交战对手的等级给予经验值。因此专挑软杭子吃是不会有人高的经验值,但打倒强敌时就能快速成长。不过这个“成长速度”也是最不容易调整的地方。</p>
<p>下面例子是计时器中显示破坏力的部分。</p>
<p>显示破坏力(Battle.cpp)</p>
<pre><code class="C++">//
// 计时器的处理
//
bool CBattleAction::TimedOut(int timerId)
{
    switch (timerId) {
        case TIMER_NUMBER_ID:   // 破坏力动画
            ASSERT(status == STATUS_ANIME);
            if (AttackAnimeCount &lt; 4) {
                for (int i=0; i&lt;NumberView; i++) {
                    Number[i].SetDrawPos(
                                        Number[i].GetDrawPos().x,
                                        Number[i].GetDrawPos().y - 1);
                    CRect   rect;
                    Number[i].GetRect(&amp;rect);
                    rect.bottom++;
                    UpdateRect(rect);
                }
            }
            else if (AttackAnimeCount &lt; 8) {
                for (int i=0; i&lt;NumberView; i++) {
                    Number[i].SetDrawPos(
                                        Number[i].GetDrawPos().x,
                                        Number[i].GetDrawPos().y + 1);
                    CRect   rect;
                    Number[i].GetRect(&amp;rect);
                    rect.top--;
                    UpdateRect(rect);
                }
            }
            else {
                int n = NumberView;
                NumberView = 0;
                for (int i=0; i&lt;n; i++) {
                    RedrawSprite(Number + i);
                }
                AttackPhase3();
                return true;
            }
            AttackAnimeCount++;
            break;
    }
}</code></pre>
<p>前面4个步骤是让显示数字往上移动(每次1dot),接下来的4个步骤则是往下移动(每次1dot)。这里是让所有数字同时移动,但也可以设计成独立或先后移动。</p>
<p>只有移动的话,显示仍然一成不变,因此重新绘制“含原显示位置与新显示位置的范围”。因为移动距离只是原显示位置的上下1dot,所以范围会逐渐扩大。</p>
<p>当数字不再移动时,即删除显示并前往第3阶段。</p>
<p>攻击的第3阶段(Battle.cpp)</p>
<pre><code class="C++">// 攻击阶段3
void CBattleAction::AttackPhase3()
{
    // 最后处理
    status = STATUS_NONE;

    // 更改游戏者状态的显示
    ChangePlayerStatus(AttackFrom);
    ChangePlayerStatus(AttackTo);

    // 判断阵亡
    if (AttackTo-&gt;status.hit_point == 0) {  // 已无HP ＝ 阵亡
        TRACE(" &gt; Killed\n");

        CPoint po = AttackTo-&gt;GetMapPoint();
        map_data[po.y][po.x].sprite = 0;
        map_data[po.y][po.x].type &amp;= ~(PLAYER | ENEMY | OBJECT);
        RemoveSprite(AttackTo);     // 从sprite清单中删除

        //
        // 判断战斗结束
        //
        // 这里的结束条件是有一方全军覆没，
        // 因此当有人物阵亡时即须判断。
        //
        if (turn == PLAYER_TURN) {
            list&lt;CCharacter&gt;::iterator p = find(enemy_list.begin(),
                            enemy_list.end(), *AttackTo);
            if (&amp;*p != AttackTo) {
                TRACE("error\n");
            }
            ASSERT(p != enemy_list.end());
            enemy_list.erase(p);
            if (enemy_list.empty()) {   // 全军覆没
                TRACE("战胜\n");
                status = STATUS_BATTLE_END;

                // 从这里开始，故事大纲继续往下走。
            }
        }
        else {
            list&lt;CCharacter&gt;::iterator p = find(player_list.begin(),
                            player_list.end(), *AttackTo);
            if (&amp;*p != AttackTo) {
                TRACE("error\n");
            }
            ASSERT(p != player_list.end());
            player_list.erase(p);
            if (player_list.empty()) {  // 全军覆没
                TRACE("战败\n");
                status = STATUS_BATTLE_END;

                // 这里不是游戏结束，
                // 就是往战败的故事大纲发展下去。
            }
        }
    }
}</code></pre>
<p>攻击的第3段是判断攻击后的情况。</p>
<p>在计算和显示完成后,开始做人物“阵亡”时的处理。已阵亡的人物须从地图上删除,若所有人物均阵亡则战斗结束。因为我们还没写出战斗结束相关的故事大纲,因此只显示除错用消息来表示战斗结束,反正先判断双方的胜负如何,记得把注解写上去就好。</p>
<p>这样看起来,整合动画的显示还真麻烦呢!还有游戏规则、动作也都需要“跑一次才知道有没有问题”,真的挺辛苦的。</p>
<p>哈,有些游戏的趣味性是要等到一头栽下去才能体会得到。</p>                            </section>
                        </div>
                        <div class="search-results">
                            <div class="has-results">
                                <h1 class="search-results-title">
                                    关于"<span class='search-query'></span>"的搜索结果共<span class='search-results-count'></span>条
                                </h1>
                                <ul class="search-results-list"></ul>
                            </div>
                            <div class="no-results">
                                <h1 class="search-results-title">没有"<span class='search-query'></span>"相关内容</h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                <a href="https://naka1205.github.io/rpgsample/p/DE18A13DD466BCF5.html" class="navigation navigation-prev " aria-label="战斗规则">
            <i class="fa fa-angle-left"></i>
        </a>
                <a href="https://naka1205.github.io/rpgsample/p/D6377D95C3DAE065.html" class="navigation navigation-next " aria-label="魔法攻击的处理">
            <i class="fa fa-angle-right"></i>
        </a>
               
    </div>
<script>
var gitbook = gitbook || [];
gitbook.push(function() {
    gitbook.page.hasChanged({
        "page": {
            "title":  "攻击时的动画",
            "next": {
                "title": "魔法攻击的处理"
            },
            "previous": {
                "title": "战斗规则"
            }
        },
        "config": {
            "gitbook": "*",
            "theme": "default",
            "variables": {},
            "plugins": ["-lunr", "-search", "-highlight","search-pro"],
            "pluginsConfig": {
                "search-pro": {},
                "highlight": {},
                "sharing": {},
                "fontsettings": {},
                "theme-default": {}
            },
            "structure": {},
            "pdf": {},
            "styles": {}
        },
        "file": {},
        "gitbook": {},
        "basePath": "https://naka1205.github.io/rpgsample",
        "book": {}
    });
});
</script>
</div>
<script src="https://naka1205.github.io/rpgsample/assets/js/gitbook.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/theme.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/jquery.mark.min.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/search.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/buttons.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/fontsettings.js"></script>
<script src="https://naka1205.github.io/rpgsample/assets/js/plugin.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
</body>
</html>