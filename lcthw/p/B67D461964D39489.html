<!DOCTYPE HTML>
<html lang=""> 
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>高级数据类型和控制结构 · 笨办法学C</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="description" content="这个练习是C语言中所有可用的数据类型和控制结构的摘要。它也可以作为一份参考在补完你的知识，并且不含有任何代码。我会通过创建教学卡片的方式，让你记住一些信息，所以你会在脑子里记住所有重要的概念。">
    <meta name="keywords" content="笨办法学C">
    <meta name="generator" content="PKBook">
    <link rel="stylesheet" href="https://naka1205.github.io/lcthw/assets/css/style.css">
    <link rel="stylesheet" href="https://naka1205.github.io/lcthw/assets/css/search.css">
    <link rel="stylesheet" href="https://naka1205.github.io/lcthw/assets/css/ebook.css">
    <link rel="stylesheet" href="https://naka1205.github.io/lcthw/assets/css/website.css">
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/github.min.css" rel="stylesheet">
    <meta name="HandheldFriendly" content="true" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://naka1205.github.io/lcthw/assets/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://naka1205.github.io/lcthw/assets/images/favicon.ico" type="image/x-icon">
</head>
<body>
<div class="book">
    <div class="book-summary">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="输入关键词搜索" />
        </div>
        <nav role="navigation">
    <ul class="summary">
        <li ><a href="https://naka1205.github.io/lcthw/index.html" class="header ">导言：C的笛卡尔之梦</a></li>
        <li class="divider"></li>
                <li class="header">练习</li>
                        <li class="chapter " data-level="1.1" data-path="https://naka1205.github.io/lcthw/p/C3D207FADFAF5841.html"><a href="https://naka1205.github.io/lcthw/p/C3D207FADFAF5841.html">准备</a></li>
                        <li class="chapter " data-level="1.2" data-path="https://naka1205.github.io/lcthw/p/6C82D57E03DDE1F0.html"><a href="https://naka1205.github.io/lcthw/p/6C82D57E03DDE1F0.html">启用编译器</a></li>
                        <li class="chapter " data-level="1.3" data-path="https://naka1205.github.io/lcthw/p/44DB81B8DEDE247B.html"><a href="https://naka1205.github.io/lcthw/p/44DB81B8DEDE247B.html">用Make来代替Python</a></li>
                        <li class="chapter " data-level="1.4" data-path="https://naka1205.github.io/lcthw/p/D3BE6C8A075EF92E.html"><a href="https://naka1205.github.io/lcthw/p/D3BE6C8A075EF92E.html">格式化输出</a></li>
                        <li class="chapter " data-level="1.5" data-path="https://naka1205.github.io/lcthw/p/B9CDA195B24A4F6A.html"><a href="https://naka1205.github.io/lcthw/p/B9CDA195B24A4F6A.html">Valgrind 介绍</a></li>
                        <li class="chapter " data-level="1.6" data-path="https://naka1205.github.io/lcthw/p/624C7D3C62504470.html"><a href="https://naka1205.github.io/lcthw/p/624C7D3C62504470.html">一个C程序的结构</a></li>
                        <li class="chapter " data-level="1.7" data-path="https://naka1205.github.io/lcthw/p/33CC823F6781FDB9.html"><a href="https://naka1205.github.io/lcthw/p/33CC823F6781FDB9.html">变量类型</a></li>
                        <li class="chapter " data-level="1.8" data-path="https://naka1205.github.io/lcthw/p/171C2758259C8DE1.html"><a href="https://naka1205.github.io/lcthw/p/171C2758259C8DE1.html">更多变量和一些算术</a></li>
                        <li class="chapter " data-level="1.9" data-path="https://naka1205.github.io/lcthw/p/C2C3F49A54034E72.html"><a href="https://naka1205.github.io/lcthw/p/C2C3F49A54034E72.html">大小和数组</a></li>
                        <li class="chapter " data-level="1.10" data-path="https://naka1205.github.io/lcthw/p/3046A11FC869E5C2.html"><a href="https://naka1205.github.io/lcthw/p/3046A11FC869E5C2.html">数组和字符串</a></li>
                        <li class="chapter " data-level="1.11" data-path="https://naka1205.github.io/lcthw/p/3018A6B457AE4FF5.html"><a href="https://naka1205.github.io/lcthw/p/3018A6B457AE4FF5.html">字符串数组和循环</a></li>
                        <li class="chapter " data-level="1.12" data-path="https://naka1205.github.io/lcthw/p/F552B2B9C8E36656.html"><a href="https://naka1205.github.io/lcthw/p/F552B2B9C8E36656.html">While循环和布尔表达式</a></li>
                        <li class="chapter " data-level="1.13" data-path="https://naka1205.github.io/lcthw/p/71D0E364C2783A96.html"><a href="https://naka1205.github.io/lcthw/p/71D0E364C2783A96.html">If，Else If，Else</a></li>
                        <li class="chapter " data-level="1.14" data-path="https://naka1205.github.io/lcthw/p/0E9AB6AD5C029EF6.html"><a href="https://naka1205.github.io/lcthw/p/0E9AB6AD5C029EF6.html">Switch语句</a></li>
                        <li class="chapter " data-level="1.15" data-path="https://naka1205.github.io/lcthw/p/5D2945A8677CE165.html"><a href="https://naka1205.github.io/lcthw/p/5D2945A8677CE165.html">编写并使用函数</a></li>
                        <li class="chapter " data-level="1.16" data-path="https://naka1205.github.io/lcthw/p/8B5745CD2156FCC3.html"><a href="https://naka1205.github.io/lcthw/p/8B5745CD2156FCC3.html">指针，可怕的指针</a></li>
                        <li class="chapter " data-level="1.17" data-path="https://naka1205.github.io/lcthw/p/CDCC108031940336.html"><a href="https://naka1205.github.io/lcthw/p/CDCC108031940336.html">结构体和指向它们的指针</a></li>
                        <li class="chapter " data-level="1.18" data-path="https://naka1205.github.io/lcthw/p/178F8DDE733AD0DD.html"><a href="https://naka1205.github.io/lcthw/p/178F8DDE733AD0DD.html">堆和栈的内存分配</a></li>
                        <li class="chapter " data-level="1.19" data-path="https://naka1205.github.io/lcthw/p/DC3B5E7AC8CF3946.html"><a href="https://naka1205.github.io/lcthw/p/DC3B5E7AC8CF3946.html">函数指针</a></li>
                        <li class="chapter " data-level="1.20" data-path="https://naka1205.github.io/lcthw/p/746ADCFC76734882.html"><a href="https://naka1205.github.io/lcthw/p/746ADCFC76734882.html">一个简单的对象系统</a></li>
                        <li class="chapter " data-level="1.21" data-path="https://naka1205.github.io/lcthw/p/8BBFC8E0CA1C348B.html"><a href="https://naka1205.github.io/lcthw/p/8BBFC8E0CA1C348B.html">Zed的强大的调试宏</a></li>
                        <li class="chapter  active " data-level="1.22" data-path="https://naka1205.github.io/lcthw/p/B67D461964D39489.html"><a href="https://naka1205.github.io/lcthw/p/B67D461964D39489.html">高级数据类型和控制结构</a></li>
                        <li class="chapter " data-level="1.23" data-path="https://naka1205.github.io/lcthw/p/6822F5C25F64C05F.html"><a href="https://naka1205.github.io/lcthw/p/6822F5C25F64C05F.html">栈、作用域和全局</a></li>
                        <li class="chapter " data-level="1.24" data-path="https://naka1205.github.io/lcthw/p/F6AD606057D5DA1A.html"><a href="https://naka1205.github.io/lcthw/p/F6AD606057D5DA1A.html">认识达夫设备</a></li>
                        <li class="chapter " data-level="1.25" data-path="https://naka1205.github.io/lcthw/p/2F13B44DB3CFDC2E.html"><a href="https://naka1205.github.io/lcthw/p/2F13B44DB3CFDC2E.html">输入输出和文件</a></li>
                        <li class="chapter " data-level="1.26" data-path="https://naka1205.github.io/lcthw/p/2852FA26A8BCFAD2.html"><a href="https://naka1205.github.io/lcthw/p/2852FA26A8BCFAD2.html">变参函数</a></li>
                        <li class="chapter " data-level="1.27" data-path="https://naka1205.github.io/lcthw/p/41ABE0D9F5D3164C.html"><a href="https://naka1205.github.io/lcthw/p/41ABE0D9F5D3164C.html">编写第一个真正的程序</a></li>
                        <li class="chapter " data-level="1.28" data-path="https://naka1205.github.io/lcthw/p/FFD032B7FC697307.html"><a href="https://naka1205.github.io/lcthw/p/FFD032B7FC697307.html">创造性和防御性编程</a></li>
                        <li class="chapter " data-level="1.29" data-path="https://naka1205.github.io/lcthw/p/5C8A5BE0B219BE30.html"><a href="https://naka1205.github.io/lcthw/p/5C8A5BE0B219BE30.html">Makefile 进阶</a></li>
                        <li class="chapter " data-level="1.30" data-path="https://naka1205.github.io/lcthw/p/09D69E06B935E885.html"><a href="https://naka1205.github.io/lcthw/p/09D69E06B935E885.html">库和链接</a></li>
                        <li class="chapter " data-level="1.31" data-path="https://naka1205.github.io/lcthw/p/866A23BE27D0D7E6.html"><a href="https://naka1205.github.io/lcthw/p/866A23BE27D0D7E6.html">自动化测试</a></li>
                        <li class="chapter " data-level="1.32" data-path="https://naka1205.github.io/lcthw/p/B6E48A0ED7072528.html"><a href="https://naka1205.github.io/lcthw/p/B6E48A0ED7072528.html">代码调试</a></li>
                        <li class="chapter " data-level="1.33" data-path="https://naka1205.github.io/lcthw/p/364477FB0CED1A03.html"><a href="https://naka1205.github.io/lcthw/p/364477FB0CED1A03.html">双向链表</a></li>
                        <li class="chapter " data-level="1.34" data-path="https://naka1205.github.io/lcthw/p/219AB7A902A81B94.html"><a href="https://naka1205.github.io/lcthw/p/219AB7A902A81B94.html">链表算法</a></li>
                        <li class="chapter " data-level="1.35" data-path="https://naka1205.github.io/lcthw/p/4375976486E9101E.html"><a href="https://naka1205.github.io/lcthw/p/4375976486E9101E.html">动态数组</a></li>
                        <li class="chapter " data-level="1.36" data-path="https://naka1205.github.io/lcthw/p/F674E4CC423F4082.html"><a href="https://naka1205.github.io/lcthw/p/F674E4CC423F4082.html">排序和搜索</a></li>
                        <li class="chapter " data-level="1.37" data-path="https://naka1205.github.io/lcthw/p/95C8D9CEC85F55BD.html"><a href="https://naka1205.github.io/lcthw/p/95C8D9CEC85F55BD.html">更安全的字符串</a></li>
                        <li class="chapter " data-level="1.38" data-path="https://naka1205.github.io/lcthw/p/19B22BBE112EDD42.html"><a href="https://naka1205.github.io/lcthw/p/19B22BBE112EDD42.html">哈希表</a></li>
                        <li class="chapter " data-level="1.39" data-path="https://naka1205.github.io/lcthw/p/8ACDB75ECC6C4448.html"><a href="https://naka1205.github.io/lcthw/p/8ACDB75ECC6C4448.html">哈希算法</a></li>
                        <li class="chapter " data-level="1.40" data-path="https://naka1205.github.io/lcthw/p/1D54A74DB0C212CF.html"><a href="https://naka1205.github.io/lcthw/p/1D54A74DB0C212CF.html">字符串算法</a></li>
                        <li class="chapter " data-level="1.41" data-path="https://naka1205.github.io/lcthw/p/64206F3FDC812F26.html"><a href="https://naka1205.github.io/lcthw/p/64206F3FDC812F26.html">二叉搜索树</a></li>
                        <li class="chapter " data-level="1.42" data-path="https://naka1205.github.io/lcthw/p/35162CDAACDA8825.html"><a href="https://naka1205.github.io/lcthw/p/35162CDAACDA8825.html">将 Cachegrind 和 Callgrind 用于性能调优</a></li>
                        <li class="chapter " data-level="1.43" data-path="https://naka1205.github.io/lcthw/p/288E5C87D0D80787.html"><a href="https://naka1205.github.io/lcthw/p/288E5C87D0D80787.html">栈和队列</a></li>
                        <li class="chapter " data-level="1.44" data-path="https://naka1205.github.io/lcthw/p/EFA4890803FAB6F6.html"><a href="https://naka1205.github.io/lcthw/p/EFA4890803FAB6F6.html">一个简单的统计引擎</a></li>
                        <li class="chapter " data-level="1.45" data-path="https://naka1205.github.io/lcthw/p/E0AFFDAFB6FE468C.html"><a href="https://naka1205.github.io/lcthw/p/E0AFFDAFB6FE468C.html">环形缓冲区</a></li>
                        <li class="chapter " data-level="1.46" data-path="https://naka1205.github.io/lcthw/p/EEC00C835A3D8361.html"><a href="https://naka1205.github.io/lcthw/p/EEC00C835A3D8361.html">一个简单的TCP/IP客户端</a></li>
                        <li class="chapter " data-level="1.47" data-path="https://naka1205.github.io/lcthw/p/51762D35312252D6.html"><a href="https://naka1205.github.io/lcthw/p/51762D35312252D6.html">三叉搜索树</a></li>
                        <li class="chapter " data-level="1.48" data-path="https://naka1205.github.io/lcthw/p/A0F3E9CEEB1897B5.html"><a href="https://naka1205.github.io/lcthw/p/A0F3E9CEEB1897B5.html">一个快速的URL路由</a></li>
                    <li class="divider"></li>
                <li class="header">后记</li>
                        <li class="chapter " data-level="2.1" data-path="https://naka1205.github.io/lcthw/p/ACB13F6E3D683928.html"><a href="https://naka1205.github.io/lcthw/p/ACB13F6E3D683928.html">解构 K&amp;R C&rdquo; 已死</a></li>
                    <li class="divider"></li>
                <li><a href="https://github.com/naka1205/pkbook" target="blank" class="gitbook-link">Published with PKBook</a></li>
    </ul>
</nav>
    </div>
    
    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
                <h1><i class="fa fa-circle-o-notch fa-spin"></i><a href="https://naka1205.github.io/lcthw/p/B67D461964D39489.html">高级数据类型和控制结构</a></h1>
            </div>
            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                    <div id="book-search-results">
                        <div class="search-noresults">
                            <section class="normal markdown-section">
                                <h1 id="%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84" name="%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">高级数据类型和控制结构</h1>
<p>这个练习是C语言中所有可用的数据类型和控制结构的摘要。它也可以作为一份参考在补完你的知识，并且不含有任何代码。我会通过创建教学卡片的方式，让你记住一些信息，所以你会在脑子里记住所有重要的概念。</p>
<p>这个练习非常有用，你应该花至少一周的时间来巩固内容并且补全这里所没有的元素。你应学出每个元素是什么意思，以及编写程序来验证你得出的结论。</p>
<h2 id="%E5%8F%AF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" name="%E5%8F%AF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">可用的数据类型</h2>
<p><code>int</code></p>
<p>储存普通的整数，默认为32位大小。</p>
<blockquote>
<p>译者注：<code>int</code>在32或64位环境下为32位，但它不应该被看作平台无关的。如果需要用到平台无关的定长整数，请使用<code>int(n)_t</code>。</p>
</blockquote>
<p><code>double</code></p>
<p>储存稍大的浮点数。</p>
<p><code>float</code></p>
<p>储存稍小的浮点数。</p>
<p><code>char</code></p>
<p>储存单字节字符。</p>
<p><code>void</code></p>
<p>表示“无类型”，用于声明不返回任何东西的函数，或者所指类型不明的指针，例如<code>void *thing</code>。</p>
<p><code>enum</code></p>
<p>枚举类型，类似于整数，也可转换为整数，但是通过符号化的名称访问或设置。当<code>switch</code>语句中没有覆盖到所有枚举的元素时，一些编译器会发出警告。</p>
<h2 id="%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6" name="%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6">类型修饰符</h2>
<p><code>unsigned</code></p>
<p>修改类型，使它不包含任何负数，同时上界变高。</p>
<p><code>signed</code></p>
<p>可以储存正数和负数，但是上界会变为（大约）一半，下界变为和上界（大约）等长。</p>
<blockquote>
<p>译者注：符号修饰符只对<code>char</code>和<code>*** int</code>有效。<code>*** int</code>默认为<code>signed</code>，而<code>char</code>根据具体实现，可以默认为<code>signed</code>，也可以为<code>unsigned</code>。</p>
</blockquote>
<p><code>long</code></p>
<p>对该类型使用较大的空间，使它能存下更大的数，通常使当前大小加倍。</p>
<p><code>short</code></p>
<p>对该类型使用较小的空间，使它储存能力变小，但是占据空间也变成一半。</p>
<h2 id="%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6" name="%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6">类型限定符</h2>
<p><code>const</code></p>
<p>表示变量在初始化后不能改变。</p>
<p><code>volatile</code></p>
<p>表示会做最坏的打算，编译器不会对它做任何优化。通常仅在对变量做一些奇怪的事情时，才会用到它。</p>
<p><code>register</code></p>
<p>强制让编译器将这个变量保存在寄存器中，并且也可以无视它。目前的编译器更善于处理在哪里存放变量，所以应该只在确定这样会提升性能时使用它。</p>
<h2 id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" name="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</h2>
<p>C使用了一种“阶梯形类型提升”的机制，它会观察运算符两边的变量，并且在运算之前将较小边的变量转换为较大边。这个过程按照如下顺序：</p>
<ul>
<li>long double</li>
<li>double</li>
<li>float</li>
<li>long long</li>
<li>long</li>
<li>int (short, char)</li>
</ul>
<blockquote>
<p>译者注：<code>short</code>和<code>char</code>会在运算之前转换成<code>int</code>。同种类型的<code>unsigned</code>和<code>signed</code>运算，<code>signed</code>保持字节不变转换成<code>unsigned</code>。</p>
</blockquote>
<h2 id="%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F" name="%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F">类型大小</h2>
<p><code>stdint.h</code>为定长的整数类型定义了一些<code>typedef</code>，同时也有一些用于这些类型的宏。这比老的<code>limits.h</code>更加易于使用，因为它是不变的。这些类型如下：</p>
<p><code>int8_t</code></p>
<p>8位符号整数。</p>
<p><code>uint8_t</code></p>
<p>8位无符号整数。</p>
<p><code>int16_t</code></p>
<p>16位符号整数。</p>
<p><code>uint16_t</code></p>
<p>16位无符号整数。</p>
<p><code>int32_t</code></p>
<p>32位符号整数。</p>
<p><code>uint32_t</code></p>
<p>32位无符号整数。</p>
<p><code>int64_t</code></p>
<p>64位符号整数。</p>
<p><code>uint64_t</code></p>
<p>64位无符号整数。</p>
<blockquote>
<p>译者注：当用于对类型大小有要求的特定平台时，可以使用这些类型。如果你怕麻烦，不想处理平台相关类型的今后潜在的扩展的话，也可以使用这些类型。</p>
</blockquote>
<p>下面的模式串为<code>(u)int(BITS)_t</code>，其中前面的<code>u</code>代表<code>unsigned</code>，<code>BITS</code>是所占位数的大小。这些模式串返回了这些类型的最大（或最小）值。</p>
<p><code>INT(N)_MAX</code></p>
<p><code>N</code>位符号整数的最大正值，例如<code>INT16_MAX</code>。</p>
<p><code>INT(N)_MIN</code></p>
<p><code>N</code>位符号整数的最小负值。</p>
<p><code>UINT(N)_MAX</code></p>
<p><code>N</code>位无符号整数的最大正值。为什么不定义其最小值，是因为最小值是0，不可能出现负值。</p>
<blockquote>
<p>警告</p>
</blockquote>
<blockquote>
<p>要注意，不要从字面上在任何头文件中去找<code>INT(N)_MAX</code>的定义。这里的<code>N</code>应该为特定整数，比如8、16、32、64，甚至可能是128。我在这个练习中使用了这个记法，就不需要显式写出每一个不同的组合了。</p>
</blockquote>
<p>在<code>stdint.h</code>中，对于<code>size_t</code>类型和足够存放指针的整数也有一些宏定义，以及其它便捷类型的宏定义。编译器至少要保证它们为某一大小，并允许它们为更大的大小。</p>
<p><code>int_least(N)_t</code></p>
<p>至少<code>N</code>位的整数。</p>
<p><code>uint_least(N)_t</code></p>
<p>至少<code>N</code>位的无符号整数。</p>
<p><code>INT_LEAST(N)_MAX</code></p>
<p><code>int_least(N)_t</code>类型的最大值。</p>
<p><code>INT_LEAST(N)_MIN</code></p>
<p><code>int_least(N)_t</code>类型的最小值。</p>
<p><code>UINT_LEAST(N)_MAX</code></p>
<p><code>uint_least(N)_t</code>的最大值。</p>
<p><code>int_fast(N)_t</code></p>
<p>与<code>int_least(N)_t</code>相似，但是是至少<code>N</code>位的“最快”整数。</p>
<p><code>uint_fast(N)_t</code></p>
<p>至少<code>N</code>位的“最快”无符号整数。</p>
<p><code>INT_FAST(N)_MAX</code></p>
<p><code>int_fast(N)_t</code>的最大值。</p>
<p><code>INT_FAST(N)_MIN</code></p>
<p><code>int_fast(N)_t</code>的最小值。</p>
<p><code>UINT_FAST(N)_MAX</code></p>
<p><code>uint_fast(N)_t</code>的最大值。</p>
<p><code>intptr_t</code></p>
<p>足够存放指针的符号整数。</p>
<p><code>uintptr_t</code></p>
<p>足够存放指针的无符号整数。</p>
<p><code>INTPTR_MAX</code></p>
<p><code>intptr_t</code>的最大值。</p>
<p><code>INTPTR_MIN</code></p>
<p><code>intptr_t</code>的最小值。</p>
<p><code>UINTPTR_MAX</code></p>
<p><code>uintptr_t</code>的最大值。</p>
<p><code>intmax_t</code></p>
<p>系统中可能的最大尺寸的整数类型。</p>
<p><code>uintmax_t</code></p>
<p>系统中可能的最大尺寸的无符号整数类型。</p>
<p><code>INTMAX_MAX</code></p>
<p><code>intmax_t</code>的最大值。</p>
<p><code>INTMAX_MIN</code></p>
<p><code>intmax_t</code>的最小值。</p>
<p><code>UINTMAX_MAX</code></p>
<p><code>uintmax_t</code>的最大值。</p>
<p><code>PTRDIFF_MIN</code></p>
<p><code>ptrdiff_t</code>的最小值。</p>
<p><code>PTRDIFF_MAX</code></p>
<p><code>ptrdiff_t</code>的最大值。</p>
<p><code>SIZE_MAX</code></p>
<p><code>size_t</code>的最大值。</p>
<h2 id="%E5%8F%AF%E7%94%A8%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6" name="%E5%8F%AF%E7%94%A8%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">可用的运算符</h2>
<p>这是一个全面的列表，关于你可以在C中使用的全部运算符。这个列表中我会标明一些东西：</p>
<p>二元</p>
<p>该运算符有左右两个操作数：<code>X + Y</code>。</p>
<p>一元</p>
<p>该运算符作用于操作数本身<code>-X</code>。</p>
<p>前缀</p>
<p>该运算符出现在操作数之前：<code>++X</code>。</p>
<p>后缀</p>
<p>通常和前缀版本相似，但是出现在操作数之后，并且意义不同：<code>X++</code>。</p>
<p>三元</p>
<p>只有一个三元运算符，意思是“三个操作数”：<code>X ? Y : Z</code>。</p>
<h2 id="%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6" name="%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">算数运算符</h2>
<p>下面是基本的算数运算符，我将函数调用<code>()</code>放入其中因为它更接近“算数”运算。</p>
<p><code>()</code></p>
<p>函数调用。</p>
<p>二元 <code>*</code></p>
<p>乘法。</p>
<p><code>/</code></p>
<p>除法。</p>
<p>二元 <code>+</code></p>
<p>加法。</p>
<p>一元 <code>+</code></p>
<p>无变化。</p>
<p>后缀 <code>++</code></p>
<p>读取变量然后自增。</p>
<p>前缀 <code>++</code></p>
<p>自增变量然后读取。</p>
<p>后缀 <code>--</code></p>
<p>读取变量然后自减。</p>
<p>前缀 <code>--</code></p>
<p>自减变量然后读取。</p>
<p>二元 <code>-</code></p>
<p>减法。</p>
<p>一元 <code>-</code></p>
<p>取反，可用于表示负数。</p>
<h2 id="%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97" name="%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97">数据运算</h2>
<p>它们用于以不同方式和形式访问数据。</p>
<p><code>-&gt;</code></p>
<p>结构体指针的成员访问。一元<code>*</code>和<code>.</code>运算符的复合。</p>
<p><code>.</code></p>
<p>结构体值的成员访问。</p>
<p><code>[]</code></p>
<p>取数组下标。二元<code>+</code>和一元<code>*</code>运算符的复合。</p>
<p><code>sizeof</code></p>
<p>取类型或变量大小。</p>
<p>一元 <code>&amp;</code></p>
<p>取地址。</p>
<p>一元 <code>*</code></p>
<p>取值（提领地址）。</p>
<h2 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" name="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</h2>
<p>它们用于测试变量的等性和不等性。</p>
<p><code>!=</code></p>
<p>不等于。</p>
<p><code>&lt;</code></p>
<p>小于。</p>
<p><code>&lt;=</code></p>
<p>小于等于。</p>
<p><code>==</code></p>
<p>等于（并不是赋值）。</p>
<p><code>&gt;</code></p>
<p>大于。</p>
<p><code>&gt;=</code></p>
<p>大于等于。</p>
<h2 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6" name="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</h2>
<p>它们更加高级，用于修改整数的原始位。</p>
<p>二元 <code>&amp;</code></p>
<p>位与。</p>
<p><code>&lt;&lt;</code></p>
<p>左移。</p>
<p><code>&gt;&gt;</code></p>
<p>右移。</p>
<p><code>^</code></p>
<p>位异或。</p>
<p><code>|</code></p>
<p>位或。</p>
<p><code>~</code></p>
<p>取补（翻转所有位）。</p>
<h2 id="%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%82" name="%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%82">布尔运算符。</h2>
<p>用于真值测试，仔细学习三元运算符，它非常有用。</p>
<p><code>!</code></p>
<p>取非。</p>
<p><code>&amp;&amp;</code></p>
<p>与。</p>
<p><code>||</code></p>
<p>或。</p>
<p><code>?:</code></p>
<p>三元真值测试，<code>X ? Y : Z</code>读作“若X则Y否则Z”。</p>
<h2 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" name="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</h2>
<p>复合赋值运算符在赋值同时执行运算。大多数上面的运算符都可以组成复合赋值运算符。</p>
<p><code>=</code></p>
<p>赋值。</p>
<p><code>%=</code></p>
<p>取余赋值。</p>
<p><code>&amp;=</code></p>
<p>位与赋值。</p>
<p><code>*=</code></p>
<p>乘法赋值。</p>
<p><code>+=</code></p>
<p>加法赋值。</p>
<p><code>-=</code></p>
<p>减法赋值。</p>
<p><code>/=</code></p>
<p>除法赋值。</p>
<p><code>&lt;&lt;=</code></p>
<p>左移赋值。</p>
<p><code>&gt;&gt;=</code></p>
<p>右移赋值。</p>
<p><code>^=</code></p>
<p>位异或赋值。</p>
<p><code>|=</code></p>
<p>位或赋值。</p>
<h2 id="%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84" name="%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">可用的控制结构</h2>
<p>下面是一些你没有接触过的控制结构：</p>
<p><code>do-while</code></p>
<p><code>do { ... } while(X);</code>首先执行花括号中的代码，之后再跳出前测试<code>X</code>表达式。</p>
<p><code>break</code></p>
<p>放在循环中用于跳出循环。</p>
<p><code>continue</code></p>
<p>跳到循环尾。</p>
<p><code>goto</code></p>
<p>跳到你已经放置<code>label</code>的位置，你已经在<code>dbg.h</code>中看到它了，用于跳到<code>error</code>标签。</p>
<h2 id="%E9%99%84%E5%8A%A0%E9%A2%98" name="%E9%99%84%E5%8A%A0%E9%A2%98">附加题</h2>
<ul>
<li>阅读<code>stdint.h</code>或它的描述，写出所有可能出现的大小定义。</li>
<li>查询本练习的每一项，写出它在代码中的作用。上网浏览资料来研究它如何正确使用。</li>
<li>将这些信息做成教学卡片，每天看上15分钟来记住它们。</li>
<li>创建一个程序，打印出每个类型的示例，并验证你的研究结果是否正确。</li>
</ul>                            </section>
                        </div>
                        <div class="search-results">
                            <div class="has-results">
                                <h1 class="search-results-title">
                                    关于"<span class='search-query'></span>"的搜索结果共<span class='search-results-count'></span>条
                                </h1>
                                <ul class="search-results-list"></ul>
                            </div>
                            <div class="no-results">
                                <h1 class="search-results-title">没有"<span class='search-query'></span>"相关内容</h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                <a href="https://naka1205.github.io/lcthw/p/8BBFC8E0CA1C348B.html" class="navigation navigation-prev " aria-label="Zed的强大的调试宏">
            <i class="fa fa-angle-left"></i>
        </a>
                <a href="https://naka1205.github.io/lcthw/p/6822F5C25F64C05F.html" class="navigation navigation-next " aria-label="栈、作用域和全局">
            <i class="fa fa-angle-right"></i>
        </a>
               
    </div>
<script>
var gitbook = gitbook || [];
gitbook.push(function() {
    gitbook.page.hasChanged({
        "page": {
            "title":  "高级数据类型和控制结构",
            "next": {
                "title": "栈、作用域和全局"
            },
            "previous": {
                "title": "Zed的强大的调试宏"
            }
        },
        "config": {
            "gitbook": "*",
            "theme": "default",
            "variables": {},
            "plugins": ["-lunr", "-search", "-highlight","search-pro"],
            "pluginsConfig": {
                "search-pro": {},
                "highlight": {},
                "sharing": {},
                "fontsettings": {},
                "theme-default": {}
            },
            "structure": {},
            "pdf": {},
            "styles": {}
        },
        "file": {},
        "gitbook": {},
        "basePath": "https://naka1205.github.io/lcthw",
        "book": {}
    });
});
</script>
</div>
<script src="https://naka1205.github.io/lcthw/assets/js/gitbook.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/theme.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/jquery.mark.min.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/search.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/buttons.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/fontsettings.js"></script>
<script src="https://naka1205.github.io/lcthw/assets/js/plugin.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
</body>
<script>
var page_id = 'B67D461964D39489';
</script>
</html>